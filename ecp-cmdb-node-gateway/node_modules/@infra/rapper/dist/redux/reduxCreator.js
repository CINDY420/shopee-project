"use strict";
exports.__esModule = true;
exports.createDataSelectorStr = exports.createBaseSelectorStr = exports.createUseRapStr = exports.createActionStr = void 0;
var tools_1 = require("../core/tools");
/** define request types */
function getRequestTypesStr(interfaces) {
    return "export const RequestTypes = {\n    ".concat(interfaces
        .map(function (_a) {
        var modelName = _a.modelName;
        return "\n          '".concat(modelName, "': [\n              '").concat(modelName, "_REQUEST',\n              '").concat(modelName, "_SUCCESS',\n              '").concat(modelName, "_FAILURE',\n          ],\n        ");
    })
        .join('\n\n'), "\n  }");
}
/** generate Action definition */
function createActionStr(interfaces, extr) {
    return "\n    /** request types */\n    ".concat(getRequestTypesStr(interfaces), "\n  ");
}
exports.createActionStr = createActionStr;
/** generate useResponseï¼ŒuseAllResponse */
function createUseRapStr(interfaces, extr) {
    return "\n    /** data structure in store */\n    interface IRapperStore {\n      ".concat(interfaces
        .map(function (_a) {
        var modelName = _a.modelName;
        return "\n      '".concat(modelName, "': Array<reduxLib.IInterfaceInfo & {\n        request: IModels['").concat(modelName, "']['Req']\n        response: IResponseTypes['").concat(modelName, "']\n      }>");
    })
        .join(',\n\n'), "\n    }\n    export type TRapperStoreKey = keyof IRapperStore\n\n    export const useResponse = {\n      ").concat(interfaces
        .map(function (itf) { return "\n      ".concat((0, tools_1.creatInterfaceHelpStr)(extr.rapUrl, itf), "\n      '").concat(itf.modelName, "': function useData(\n          filter?: { request?: IModels['").concat(itf.modelName, "']['Req'] } | { (\n              storeData: IRapperStore['").concat(itf.modelName, "'][0]\n          ): boolean }\n      ) {\n        type Req = IModels['").concat(itf.modelName, "']['Req']\n        type Item = IRapperStore['").concat(itf.modelName, "'][0]\n        type Res = IResponseTypes['").concat(itf.modelName, "']\n        return reduxLib.useResponseData<TRapperStoreKey, Req, Res | undefined, Item>(\n          '").concat(itf.modelName, "', filter)\n      }"); })
        .join(',\n\n'), "\n    }\n\n    export const useAPI = {\n      ").concat(interfaces
        .map(function (itf) { return "\n      ".concat((0, tools_1.creatInterfaceHelpStr)(extr.rapUrl, itf), "\n      '").concat(itf.modelName, "': function useData(\n        requestParams?: IModels['").concat(itf.modelName, "']['Req'],\n        extra?: reduxLib.IUseAPIExtra<IModels['").concat(itf.modelName, "']['Req']>\n      ) {\n        type Req = IModels['").concat(itf.modelName, "']['Req']\n        type Res = IResponseTypes['").concat(itf.modelName, "']\n        type IFetcher = typeof fetch['").concat(itf.modelName, "']\n        return reduxLib.useAPICommon<TRapperStoreKey, Req, Res | undefined, IFetcher>({\n          modelName: '").concat(itf.modelName, "',\n          fetcher: fetch['").concat(itf.modelName, "'],\n          requestParams,\n          extra,\n        })\n      }"); })
        .join(',\n\n'), "\n    }\n\n    export const useAllResponse = {\n      ").concat(interfaces
        .map(function (itf) { return "\n      ".concat((0, tools_1.creatInterfaceHelpStr)(extr.rapUrl, itf), "\n      '").concat(itf.modelName, "': function useData() {\n        return useSelector((state: reduxLib.IState) => {\n          const selectedState = (state['$$rapperResponseData'] && state['$$rapperResponseData']['").concat(itf.modelName, "']) || []\n          type TReturnItem = reduxLib.IInterfaceInfo & {\n            request?: IModels['").concat(itf.modelName, "']['Req'];\n            response?: IResponseTypes['").concat(itf.modelName, "'];\n          }\n          return selectedState as Array<TReturnItem>\n        })\n      }"); })
        .join(',\n\n'), "\n    }\n\n    /** reset interface data */\n    export const clearResponseCache = {\n      ").concat(interfaces
        .map(function (itf) { return "\n      ".concat((0, tools_1.creatInterfaceHelpStr)(extr.rapUrl, itf), "\n      '").concat(itf.modelName, "': (): void => {\n        reduxLib.dispatchAction({\n          type: '$$RAPPER_CLEAR_STORE',\n          payload: { '").concat(itf.modelName, "': undefined }\n        })\n      }"); })
        .join(',\n\n'), "\n    }\n    ");
}
exports.createUseRapStr = createUseRapStr;
function createBaseSelectorStr(interfaces) {
    return "\n    export const rapperBaseSelector = {\n    ".concat(interfaces
        .map(function (_a) {
        var modelName = _a.modelName;
        return "\n      '".concat(modelName, "': (state: reduxLib.IState, filter?: { request?: IModels['").concat(modelName, "']['Req'] } | { (storeData: IRapperStore['").concat(modelName, "'][0]): boolean }) => {\n        type Req = IModels['").concat(modelName, "']['Req'];\n        type Res = IResponseTypes['").concat(modelName, "'];\n        type Item = IRapperStore['").concat(modelName, "'][0];\n        return reduxLib.getResponseData<TRapperStoreKey, Req, Res | undefined, Item>(state, '").concat(modelName, "', filter);\n      }\n    ");
    })
        .join(',\n\n'), "\n    }\n  ");
}
exports.createBaseSelectorStr = createBaseSelectorStr;
function createDataSelectorStr(interfaces) {
    return "\n    export const rapperDataSelector = {\n    ".concat(interfaces
        .map(function (_a) {
        var modelName = _a.modelName;
        return "\n      '".concat(modelName, "': (state: reduxLib.IState) => {\n        type Res = IResponseTypes['").concat(modelName, "'];\n        return reduxLib.getRapperDataSelector<TRapperStoreKey, Res>(state, '").concat(modelName, "');\n      }\n    ");
    })
        .join(',\n\n'), "\n    }\n  ");
}
exports.createDataSelectorStr = createDataSelectorStr;
