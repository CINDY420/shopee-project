"use strict";
exports.__esModule = true;
exports.findRapperVersion = exports.findChangeFiles = exports.findDeleteFiles = void 0;
/**
 * Scan the project file to exclude the existence of the rap interface has been deleted, but the project is still using the interface
 */
var fs = require("fs");
var path = require("path");
var chalk_1 = require("chalk");
var path_1 = require("path");
var utils_1 = require("../utils");
/**
 * Get all the files that need to be scanned
 * @param parentPath
 */
function getFiles(parentPath) {
    var fileList = [];
    /* Do not scan for invalid paths */
    if (parentPath.indexOf('/.') > -1 || parentPath.indexOf('node_modules') > -1) {
        return fileList;
    }
    var files = [];
    try {
        files = fs.readdirSync(parentPath);
    }
    catch (err) { }
    files.forEach(function (item) {
        item = path.join(parentPath, item);
        if (item.indexOf('src') < 0) {
            return;
        }
        var stat = fs.statSync(item);
        try {
            if (stat.isDirectory()) {
                fileList = fileList.concat(getFiles(item));
            }
            else if (stat.isFile()) {
                fileList.push(item);
            }
        }
        catch (error) {
            console.log(chalk_1["default"].red("rapper: Rap interface reference scan failed, ".concat(error)));
        }
    });
    return fileList;
}
/** Verify the file MD5, whether it has been changed */
function isFileChange(contentArr) {
    var matchMD5 = contentArr[0].match(/\/\*\smd5:\s(\S*)\s\*\//) || [];
    var oldMD5 = matchMD5[1];
    /** The old version is not written in md5, so it needs to be compatible here */
    if (!oldMD5) {
        return false;
    }
    return oldMD5 !== (0, utils_1.getMd5)(contentArr.slice(1).join('\n'));
}
function scanAllfiles(interfaces, fileList) {
    var strReg = /[\'\"]+(GET|POST|PUT|DELETE|OPTIONS|PATCH|HEAD)\/([^\'\"]*)[^(REQUEST)(SUCCESS)(FAILURE)]{1}[\'\"]+/g;
    var result = [];
    fileList.forEach(function (filePath) {
        /** File extension */
        var extName = path.extname(filePath);
        if (!['.ts', '.js', '.vue', '.es'].includes(extName)) {
            return;
        }
        /** Read the contents of the file */
        var content = fs.readFileSync(filePath, 'utf-8') || '';
        /** Compare each row */
        content.split('\n').forEach(function (rowText, i) {
            var regResult = rowText.match(strReg);
            if (regResult && regResult.length > 0) {
                regResult.forEach(function (item) {
                    item = item.replace(/\'|\"/gi, '');
                    /** Can't find it in interfaces, indicating invalid Rap reference */
                    var isExist = !!interfaces.find(function (_a) {
                        var modelName = _a.modelName;
                        return modelName === item;
                    });
                    if (!isExist) {
                        result.push({
                            key: item,
                            filePath: (0, path_1.resolve)(process.cwd(), filePath),
                            start: rowText.indexOf(item),
                            line: i + 1
                        });
                    }
                });
            }
        });
        return false;
    });
    return result;
}
/**
 * Scan to find out if there are any deleted interfaces
 * @param interfaces, Rap platform synchronization interface
 * @param excludePath, Exclude detected files (node_modules has been excluded by default, no need to configure this item)
 */
function findDeleteFiles(interfaces, excludePaths) {
    var fileList = getFiles('./');
    fileList = fileList.filter(function (file) {
        file = (0, path_1.resolve)(process.cwd(), file);
        return !excludePaths.find(function (exclude) { return file.indexOf((0, path_1.resolve)(process.cwd(), exclude)) > -1; });
    });
    return scanAllfiles(interfaces, fileList);
}
exports.findDeleteFiles = findDeleteFiles;
/**
 * Scan to find out whether the generated template file has been manually modified
 * @param rapperPath, Template file address
 */
function findChangeFiles(rapperPath) {
    var fileList = getFiles(rapperPath);
    var changeList = [];
    fileList.forEach(function (filePath) {
        /** Read the contents of the file */
        var content = fs.readFileSync(filePath, 'utf-8') || '';
        /** Verify the file MD5, whether it has been changed */
        if (isFileChange(content.split(/\r|\n|\r\n/))) {
            changeList.push((0, path_1.resolve)(process.cwd(), filePath));
        }
    });
    return changeList;
}
exports.findChangeFiles = findChangeFiles;
/**
 * Scan from the first 6 lines of the template file to find the rapper version that generated the template file
 */
function findRapperVersion(rapperPath) {
    var version = '';
    try {
        var content = fs.readFileSync("".concat(rapperPath, "/index.ts"), 'utf-8') || '';
        var contentArr = content.split(/\r|\n|\r\n/);
        if (contentArr.length) {
            var matchMD5 = contentArr
                .slice(0, 6)
                .join('\n')
                .match(/\/\*\sRapper version:\s(\S*)\s\*\//) || [];
            version = matchMD5[1];
        }
    }
    catch (err) { }
    return version;
}
exports.findRapperVersion = findRapperVersion;
