"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
exports.__esModule = true;
exports.interfaceToJSONSchema = exports.getRestfulPlaceHolders = exports.removeComment = void 0;
var json_schema_to_typescript_1 = require("json-schema-to-typescript");
var JSON5 = require("json5");
var _ = require("lodash");
function inferArraySchema(p, childProperties, common) {
    var rule = (p.rule && p.rule.trim()) || '';
    if (Object.keys(childProperties).length !== 0) {
        // It must be object if it has children
        return [
            p.name,
            __assign(__assign({ type: 'array', items: {
                    type: 'object',
                    properties: childProperties,
                    // move child's required to items
                    required: common.required,
                    additionalProperties: false
                } }, common), { required: [] }),
        ];
    }
    else if (['+1', '1'].includes(rule) && p.value) {
        // If rule is +1, mockjs will sequentially choose 1 element from `array` as the final value。
        // If rule is 1, mockjs will randomly choose 1 element from `array` as the final value。
        // At this time, the type of this attribute is not array, but the type of the sub-elements of array
        // The type of the child element can be inferred from the value
        try {
            var arr = JSON5.parse(p.value);
            if (Array.isArray(arr) && arr.length) {
                var type = _.chain(arr)
                    .map(function (e) { return typeof e; })
                    .uniq()
                    .value();
                return [
                    p.name,
                    __assign({ type: type }, common),
                ];
            }
            else {
                // resolve failed，return any
                return [
                    p.name,
                    __assign({ type: ['string', 'number', 'boolean', 'object'] }, common),
                ];
            }
        }
        catch (error) {
            // resolve failed，return any
            return [
                p.name,
                __assign({ type: ['string', 'number', 'boolean', 'object'] }, common),
            ];
        }
    }
    else if (rule === '' && p.value) {
        // When there are no descendants, value, and no generation rules, the default hack meets the problem that rap2 cannot express the problem of array<primitive>.
        // The specific type of primitive is inferred by value
        try {
            var v = JSON5.parse(p.value);
            if (Array.isArray(v)) {
                // If it is an empty array, return any[]
                if (!v.length) {
                    return [
                        p.name,
                        __assign({ type: 'array' }, common),
                    ];
                }
                // If it is an array, use the array element type
                var type = _.chain(v)
                    .map(function (e) { return typeof e; })
                    .uniq()
                    .value();
                return [
                    p.name,
                    __assign({ type: 'array', items: {
                            type: type
                        } }, common),
                ];
            }
            else {
                // If it is not an array, use the value type directly
                var type = typeof v;
                return [
                    p.name,
                    __assign({ type: 'array', items: {
                            type: type
                        } }, common),
                ];
            }
        }
        catch (error) {
            // resolve failed, return any[]
            return [
                p.name,
                __assign({ type: 'array' }, common),
            ];
        }
    }
    else {
        // no generate rules and no values，generate any[]
        return [
            p.name,
            __assign({ type: 'array' }, common),
        ];
    }
}
var removeComment = function (str) { return str.replace(/\/\*|\*\//g, ''); };
exports.removeComment = removeComment;
function getRestfulPlaceHolders(url) {
    var urlSplit = url.split('/');
    var restfulPlaceHolders = [];
    for (var i = 0; i < urlSplit.length; ++i) {
        var part = urlSplit[i];
        var matchKeys = part.match(/(?:\{(.+)\}|\:(.+))/);
        if (!matchKeys)
            continue;
        var key = matchKeys[1] || matchKeys[2];
        restfulPlaceHolders.push(key);
    }
    return restfulPlaceHolders;
}
exports.getRestfulPlaceHolders = getRestfulPlaceHolders;
function interfaceToJSONSchema(itf, scope) {
    var properties = itf.properties.filter(function (p) { return p.scope === scope; });
    properties = __spreadArray(__spreadArray([], properties, true), [
        {
            name: 'dummyroot',
            parentId: -2,
            id: -1,
            scope: scope,
            type: 'object'
        },
    ], false);
    if (scope === 'request') {
        var placeHolders = getRestfulPlaceHolders(itf.url);
        properties = __spreadArray(__spreadArray([], properties, true), placeHolders.map(function (name, index) { return ({
            name: name,
            parentId: -1,
            id: index + 100,
            scope: scope,
            type: 'string'
        }); }), true);
    }
    function findChildProperties(parentId) {
        return _.chain(properties)
            .filter(function (p) { return p.parentId === parentId; })
            .map(function (p) {
            var type = p.type.toLowerCase().replace(/regexp|function/, 'string');
            var childProperties = findChildProperties(p.id);
            var childItfs = properties.filter(function (x) { return x.parentId === p.id; });
            var common = {
                // By default, all attributes have values
                additionalProperties: false,
                required: childItfs.filter(function (e) { return e.required; }).map(function (e) { return e.name; })
            };
            if (p.description)
                common.description = (0, exports.removeComment)(p.description);
            /**
             * Processing enumeration, supports the following forms: (currently controls the scope of influence, only string and number are processed)
             * value="@pick(['p1', 'p2'])"
             * issue link：https://github.com/thx/rapper/issues/9
             */
            if (['string', 'number'].includes(type) && p.value) {
                var enumArr = [];
                var regResult = /^@pick\(([\s\S]+)\)$/.exec(p.value);
                try {
                    if (regResult) {
                        var result = regResult[1];
                        enumArr = eval(result);
                    }
                }
                catch (err) { }
                if (Array.isArray(enumArr) && enumArr.length) {
                    common["enum"] = enumArr;
                }
            }
            if (['string', 'number', 'integer', 'boolean', 'null'].includes(type)) {
                return [
                    p.name,
                    __assign({ type: type }, common),
                ];
            }
            else if (type === 'object') {
                return [
                    p.name,
                    __assign({ type: type, properties: childProperties }, common),
                ];
            }
            else if (type === 'array') {
                return inferArraySchema(p, childProperties, common);
            }
            else {
                // resolve failed，return any
                return [
                    p.name,
                    __assign({ type: ['string', 'number', 'boolean', 'object'] }, common),
                ];
                // throw `type: ${type}
                // parentID: ${parentId}
                // itf.url: ${itf.url}
                // ${JSON.stringify(childProperties)}`;
            }
        })
            .fromPairs()
            .value();
    }
    var propertyChildren = findChildProperties(-2);
    var root = propertyChildren['dummyroot'];
    // When there is only one array whose key is _root_ or __root__, it means that you want to express that the root node is an array
    if (Object.keys(root.properties).length === 1 &&
        (root.properties._root_ || root.properties.__root__)) {
        var _root_ = root.properties._root_ || root.properties.__root__;
        if (_root_.type === 'array') {
            return _root_;
        }
    }
    return root;
}
exports.interfaceToJSONSchema = interfaceToJSONSchema;
function convert(itf) {
    var reqJSONSchema = interfaceToJSONSchema(itf, 'request');
    var resJSONSchema = interfaceToJSONSchema(itf, 'response');
    var options = __assign(__assign({}, json_schema_to_typescript_1.DEFAULT_OPTIONS), { bannerComment: '' });
    return Promise.all([
        (0, json_schema_to_typescript_1.compile)(reqJSONSchema, 'Req', options),
        (0, json_schema_to_typescript_1.compile)(resJSONSchema, 'Res', options),
    ]);
}
exports["default"] = convert;
