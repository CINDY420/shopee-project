import { IExtra } from './commonLib';
/** Constant definition */
export declare const RAPPER_REQUEST = "$$RAPPER_REQUEST";
export declare const RAPPER_CLEAR_STORE = "$$RAPPER_CLEAR_STORE";
export declare const RAPPER_UPDATE_STORE = "$$RAPPER_UPDATE_STORE";
export declare const RAPPER_STATE_KEY = "$$rapperResponseData";
/** useAPI extra */
export interface IUseAPIExtra<Req> extends Pick<IExtra, 'contentType' | 'query' | 'queryStringFn'> {
    /**
     * support three modesï¼Œdefault is paramsMatch
     * paramsMatch, parameter matching mode (default mode), judge whether there is data with the same request parameter in the cache, return if there is, and send the request automatically if not
     * notMatch, do not perform parameter matching mode, judge whether there is interface data in the cache, return if there is, and send the request automatically if not
     * manual, manual mode, the request is not sent automatically, the return data is the latest data obtained through the request request
     */
    mode?: 'paramsMatch' | 'notMatch' | 'manual';
    /**
     * Response data update timing, default inital
     * initial, update the response data immediately after the request is sent
     * complete, update response data only after the request is completed
     */
    updateTiming?: 'initial' | 'complete';
    /**
     * Whether to send the request
     */
    shouldAutoRequest?: (requestParams: Req) => boolean;
    /** expanded keys */
    [key: string]: any;
}
/** request method */
declare type REQUEST_METHOD = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
interface IAction<T = any> {
    type: T;
}
export interface IAnyAction extends IAction {
    [extraProps: string]: any;
}
export interface IRequestAction {
    type: typeof RAPPER_REQUEST;
    payload?: {
        modelName: string;
        url: string;
        method?: REQUEST_METHOD;
        params?: any;
        types: string[];
    };
}
export declare type TAction = IAnyAction | IRequestAction;
/** store enhancer parameter */
export interface IEnhancerProps {
    /** Maximum length of cached data */
    maxCacheLength?: number;
    /** The anti-shake interval, the default is 1000ms, if it is set to 0, the anti-shake is not */
    debounce?: number;
}
declare type Dispatch<A = IAnyAction> = <T extends A>(action: T, ...extraArgs: any[]) => T;
declare type Unsubscribe = () => void;
export declare type Reducer<S = any, A = IAnyAction> = (state: S | undefined, action: A) => S;
declare type ExtendState<IState, Extension> = [Extension] extends [never] ? IState : IState & Extension;
declare type Observer<T> = {
    next?(value: T): void;
};
declare type Observable<T> = {
    subscribe: (observer: Observer<T>) => {
        unsubscribe: Unsubscribe;
    };
    [Symbol.observable](): Observable<T>;
};
export declare type StoreEnhancer<Ext = {}, StateExt = {}> = (next: StoreEnhancerStoreCreator) => StoreEnhancerStoreCreator<Ext, StateExt>;
export declare type StoreEnhancerStoreCreator<Ext = {}, StateExt = {}> = <S = any, A extends IAction = IAnyAction>(reducer: Reducer<S, A>, preloadedState?: DeepPartial<S>) => IStore<S & StateExt, A> & Ext;
export declare type DeepPartial<T> = {
    [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};
/** IStore */
export interface IStore<S = any, A = TAction, StateExt = never, Ext = {}> {
    dispatch: Dispatch<A>;
    getState(): S;
    subscribe(listener: () => void): Unsubscribe;
    replaceReducer<NewState, NewActions>(nextReducer: Reducer<NewState, NewActions>): IStore<ExtendState<NewState, StateExt>, NewActions, StateExt, Ext> & Ext;
    [Symbol.observable](): Observable<S>;
}
declare const $CombinedState: unique symbol;
export declare type CombinedState<S> = {
    readonly [$CombinedState]?: undefined;
} & S;
export declare type PreloadedState<S> = Required<S> extends {
    [$CombinedState]: undefined;
} ? S extends CombinedState<infer S1> ? {
    [K in keyof S1]?: S1[K] extends object ? PreloadedState<S1[K]> : S1[K];
} : never : {
    [K in keyof S]: S[K] extends object ? PreloadedState<S[K]> : S[K];
};
export interface IStoreCreator {
    <S, A extends IAction, Ext = {}, StateExt = never>(reducer: Reducer<S, A>, enhancer?: StoreEnhancer<Ext, StateExt>): IStore<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext;
    <S, A extends IAction, Ext = {}, StateExt = never>(reducer: Reducer<S, A>, preloadedState?: PreloadedState<S>, enhancer?: StoreEnhancer<Ext>): IStore<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext;
}
interface IFilterObj<Req> {
    request?: Req;
}
declare type FilterFunc<Item> = (storeData: Item) => boolean;
export interface IState {
    [key: string]: any;
}
/** Get response data by hooks */
export declare function useResponseData<M, Req, Res, Item extends {
    request: Req;
}>(modelName: M, filter?: IFilterObj<Req> | FilterFunc<Item>): readonly [Res, {
    readonly id: number;
    readonly isPending: boolean;
    readonly errorMessage: string;
}];
/** class component get response data */
export declare function getResponseData<M, Req, Res, Item extends {
    request: Req;
}>(state: IState, modelName: M, filter?: IFilterObj<Req> | FilterFunc<Item>): readonly [Res, {
    readonly id: number;
    readonly isPending: boolean;
    readonly errorMessage: string;
}];
/** class component get response data */
export declare function getRapperDataSelector<M, Res>(state: IState, modelName: M): Res;
interface IRapperCommonParams<M, Req, Item, IFetcher> {
    modelName: M;
    fetcher: IFetcher;
    requestParams?: Req;
    extra?: IUseAPIExtra<Req>;
    filter?: IFilterObj<Req> | FilterFunc<Item>;
}
/** useAPI */
export declare function useAPICommon<M, Req, Res, IFetcher extends (requestParams?: Req, extra?: IExtra) => any>({ modelName, fetcher, requestParams, extra }: IRapperCommonParams<M, Req, {}, IFetcher>): readonly [Res, {
    readonly isPending: boolean;
    readonly errorMessage: string;
    readonly request: (req?: Req, extra?: {
        [key: string]: any;
        contentType?: "text/html" | "application/json" | "multipart/form-data" | "application/x-www-form-urlencoded" | "text/plain" | "application/javascript";
        query?: {
            [key: string]: any;
        };
        queryStringFn?: (input: object | any[]) => string;
    }) => Promise<any>;
}];
export interface IInterfaceInfo {
    /** The unique id of the request, temporarily equal to requestTime */
    id: number;
    /** request time */
    requestTime: number;
    /** Whether it is fetching */
    isPending: boolean;
    /** error message */
    errorMessage?: string;
    /** response time */
    reponseTime?: number;
}
export declare const rapperReducers: {
    $$rapperResponseData: (state?: {}) => {};
};
/** store enhancer */
export declare function rapperEnhancer(config?: IEnhancerProps): any;
/** send request */
export declare function dispatchAction<Res>(action: IAnyAction, fetch?: any): Promise<IAnyAction | Res>;
export {};
